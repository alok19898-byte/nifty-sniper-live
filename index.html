import time
import random
from datetime import datetime, timedelta
from rich.live import Live
from rich.table import Table
from rich.console import Console
from rich.panel import Panel
from rich.layout import Layout
from rich import box

# --- CONFIGURATION ---
STRIKE_GAP = 50
OI_CHANGE_LIMIT_LOW = 80000
OI_CHANGE_LIMIT_HIGH = 100000
SAFETY_OI_LIMIT = 11000  # Cost-to-cost exit rule

console = Console()

class NiftySniperV7:
    def __init__(self):
        self.spot_price = 25310  # Initial Dummy Spot
        self.market_start_time = datetime.now().replace(hour=9, minute=15, second=0)
        self.last_pressure_change_time = datetime.now()
        self.highest_percentage_start_time = None
        self.stuck_start_time = None
        self.current_pressure = "NEUTRAL"
        self.wtt_wtb_percentage = 70.0
        self.s_r_status = {"S_hit": False, "R_hit": False}
        self.golden_rules_triggered = []

    def fetch_data_simulation(self):
        """
        Yahan apni API ka code daalna (Angel One / Zerodha).
        Abhi ye dummy data generate kar raha hai tere rules test karne ke liye.
        """
        # Simulating Spot movement
        self.spot_price += random.choice([-5, -2, 0, 2, 5])
        
        # Simulating Call/Put Data for strikes around ATM
        atm = round(self.spot_price / 50) * 50
        strikes = [atm - 100, atm - 50, atm, atm + 50, atm + 100]
        
        data = {}
        for sk in strikes:
            data[sk] = {
                "ce_oi": random.randint(50000, 150000),
                "ce_vol": random.randint(100000, 500000),
                "ce_ltp": random.uniform(10, 150),
                "pe_oi": random.randint(50000, 150000),
                "pe_vol": random.randint(100000, 500000),
                "pe_ltp": random.uniform(10, 150),
                "ce_oi_chg": random.randint(-5000, 15000),
                "pe_oi_chg": random.randint(-5000, 15000)
            }
        return data, strikes

    def find_support_resistance_ultra(self, data, strikes):
        """
        Ultra Golden Rule 5: Paribhasha (ITM -> OTM Highest Data)
        """
        # Logic: Find highest OI/Vol
        # Simplified for demo: Just picking max from list
        # Real code mein ITM se OTM loop lagana padega
        
        # Finding R (Call Side Highest)
        r_strike = max(strikes, key=lambda x: data[x]['ce_oi'])
        r_ltp = data[r_strike]['ce_ltp']
        
        # Finding S (Put Side Highest)
        s_strike = max(strikes, key=lambda x: data[x]['pe_oi'])
        
        # Calculation Rule 6: Everything based on Resistance
        # R = Strike + LTP
        resistance_value = r_strike + r_ltp
        
        # Levels Calculation
        r_minus_1 = resistance_value - 50  # Bearish Entry
        s_plus_1 = r_minus_1 + 50          # Bullish Entry (Equivalent to R level)
        # Agar S same strike par nahi hai to R-1 hi S banega logic
        
        return r_strike, s_strike, resistance_value, r_minus_1, s_plus_1

    def check_ultra_golden_rules(self, data, strikes, s_strike, r_strike):
        self.golden_rules_triggered = []
        alerts = []
        
        now = datetime.now()
        
        # --- Rule 1: Speed (15-25 mins) ---
        if self.wtt_wtb_percentage >= 75:
            if self.highest_percentage_start_time is None:
                self.highest_percentage_start_time = now
            else:
                elapsed = (now - self.highest_percentage_start_time).seconds / 60
                if 15 <= elapsed <= 25 and self.wtt_wtb_percentage >= 99:
                    alerts.append("[bold green]ðŸš€ SPEED ALERT: 75-100% in 15-25 mins! High Prob (80%) Trade![/]")

        # --- Rule 2: Stuck & 2% Reversal ---
        if s_strike == r_strike:
            if self.stuck_start_time is None:
                self.stuck_start_time = now
            elif (now - self.stuck_start_time).seconds >= 3600: # 1 Hour stuck
                alerts.append("[bold yellow]âš ï¸ MARKET STUCK (1hr+): Trade Against Scenario (70% Prob)[/]")
        else:
            self.stuck_start_time = None
            
        # 2% Reversal Logic (Simulated)
        # (Yahan pichle tick ka percentage store karke compare karna hoga)
        
        # --- Rule 3: Low OI Change (After 9:40) ---
        if now.hour >= 9 and now.minute >= 40:
            avg_oi_chg = sum([d['ce_oi_chg'] for d in data.values()]) / len(data)
            if avg_oi_chg < 80000:
                 alerts.append("[cyan]â„¹ï¸ LOW OI DATA: Trade only from S (Bull) or R (Bear)[/]")
                 
        # --- Rule 4: SOC (3 Hours) ---
        if self.stuck_start_time and (now - self.stuck_start_time).seconds >= 10800: # 3 hours
            alerts.append("[bold red]â›” SOC ALERT: Market Confused (3 Hrs). Wait![/]")

        # --- Rule 6 (Safety): 11k Rule ---
        # Check specific strike OI change
        atm_strike = round(self.spot_price / 50) * 50
        if atm_strike in data:
            if abs(data[atm_strike]['ce_oi_chg']) > SAFETY_OI_LIMIT and self.current_pressure == "BULLISH":
                 alerts.append("[bold red on white]ðŸš¨ 11K RULE VIOLATION: COST-TO-COST EXIT NOW! ðŸš¨[/]")

        return alerts

    def generate_table(self):
        data, strikes = self.fetch_data_simulation()
        r_strike, s_strike, r_val, r_minus_1, s_plus_1 = self.find_support_resistance_ultra(data, strikes)
        alerts = self.check_ultra_golden_rules(data, strikes, s_strike, r_strike)
        
        table = Table(title=f"NIFTY SNIPER V7 (ULTRA GOLDEN) | SPOT: {self.spot_price:.2f}", box=box.ROUNDED)
        
        table.add_column("Strike", justify="center", style="cyan")
        table.add_column("CE OI", justify="right")
        table.add_column("Call LTP", justify="right", style="green")
        table.add_column("Put LTP", justify="right", style="red")
        table.add_column("PE OI", justify="right")
        table.add_column("Signal/Remark", justify="center")

        # Find where imaginary line goes
        # Line should be between strikes where spot is
        lower_bound = (int(self.spot_price) // 50) * 50
        
        sorted_strikes = sorted(strikes)
        
        for i, sk in enumerate(sorted_strikes):
            # IMAGINARY LINE LOGIC
            if sk == lower_bound + 50:
                 table.add_row(
                     "â”€â”€â”€â”€â”€", "â”€â”€â”€â”€â”€", 
                     "[bold red]ðŸ”´ IMAGINARY[/]", "[bold red]LINE ðŸ”´[/]", 
                     "â”€â”€â”€â”€â”€", f"[bold yellow]Spot: {self.spot_price}[/]"
                 )

            ce_oi = f"{data[sk]['ce_oi']:,}"
            pe_oi = f"{data[sk]['pe_oi']:,}"
            ce_ltp = f"{data[sk]['ce_ltp']:.2f}"
            pe_ltp = f"{data[sk]['pe_ltp']:.2f}"
            
            remark = ""
            if sk == r_strike: remark += "[bold red]RESISTANCE (R)[/] "
            if sk == s_strike: remark += "[bold green]SUPPORT (S)[/] "
            
            # Entry Levels Display
            # Approximation for display matching user rules
            if abs(sk - r_minus_1) < 25: remark += "â¬…ï¸ [red]ENTRY R-1[/]"
            if abs(sk - s_plus_1) < 25: remark += "â¬…ï¸ [green]ENTRY S+1[/]"

            table.add_row(str(sk), ce_oi, ce_ltp, pe_ltp, pe_oi, remark)

        return table, alerts, r_val, r_minus_1, s_plus_1

# --- MAIN LOOP ---
sniper = NiftySniperV7()

with Live(console=console, refresh_per_second=1) as live:
    while True:
        table, alerts, r_val, bear_lvl, bull_lvl = sniper.generate_table()
        
        # Footer Panel with Calculations
        footer_text = f"""[bold underline]CALCULATION (Rule 6):[/]
Resistance (R) = {r_val:.2f}
[bold green]Bullish Entry (S+1): {bull_lvl:.2f}[/]
[bold red]Bearish Entry (R-1): {bear_lvl:.2f}[/]

[bold underline]ALERTS:[/]{' '.join(alerts) if alerts else ' [dim]No Active Alerts[/]'}
"""
        layout = Layout()
        layout.split_column(
            Layout(table),
            Layout(Panel(footer_text, title="ULTRA GOLDEN RULES ENGINE", border_style="gold1"))
        )
        
        live.update(layout)
        time.sleep(1)
